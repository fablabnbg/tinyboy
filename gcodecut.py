#! /usr/bin/python
#
# gcodecut.py -- most simpilistic gcode cutter
#
# (C) 2016 juewei@fabmail.org
# distribute under GPLv2.0 or ask.
#
# Using ';LAYER:NN' comments (as e.g. generated by cura) and 
# adjusting G0 Rapid move, G1 Linear move commands.
# Accepts the cut position as layer number (integer) or absolute length (float with suffix mm)
# Absolute position mode is assumed.
# Layers with negative numbers (Raft in cura) are preserved.
#
# 2016-10-04, jw -- initial draught.
#

import sys, re

verbose=False

file = sys.argv[1]
fd = open(file, 'r')

cut_mm = None
cut_layer = None

if len(sys.argv) > 2: 
  if re.search('mm$', sys.argv[2]) is not None:
    cut_mm = re.sub('mm$', '', sys.argv[2])
    cut_mm = float(cut_mm)
  else:
    cut_layer = int(sys.argv[2])

new_layer = None
layer_0_z = 0

if cut_layer is None:
  while True:
    line = fd.readline()
    if line == '': break
    m = re.match(';LAYER:(-?\d+)', line)
    if m:
      new_layer = int(m.group(1))
    if new_layer is not None:
      m = re.match('G[01]\s.*\sZ([-\d\.]+)', line)
      if m:
        # print "Layer: %d height: Z%g" % (new_layer, float(m.group(1)))
	if new_layer == 0:
	  layer_0_z = float(m.group(1))
	  
        if cut_mm <= float(m.group(1)):
	  cut_layer = new_layer
	  break
        new_layer = None
  fd.seek(0,0)

print ";CUT_LAYER:", cut_layer

line_count = 0
byte_count = 0
new_layer = None
skip_layer = False
z_offset = 0

while True:
  line = fd.readline()
  line_count += 1
  byte_count += len(line)
  if line == '': break
  m = re.match(';LAYER:(-?\d+)', line)
  if m:
    new_layer = int(m.group(1))
    if new_layer >= 0 and new_layer < cut_layer: 
      skip_layer = True
    else:
      skip_layer = False
  if new_layer is not None and new_layer == cut_layer:
    m = re.match('G[01]\s.*\sZ([-\d\.]+)', line)
    if m:
      z_offset = float(m.group(1)) - layer_0_z
      print ";LAYER_OFFSET:%g" % z_offset
      print ";LAYER_CUT:%d" % cut_layer
      new_layer = None
  if not skip_layer:
    line = re.sub('(G[01]\s.*Z)([-\d\.]+)(.*)', lambda m: m.group(1)+str(float(m.group(2))-z_offset)+m.group(3), line)
    # make layer numbers consecutive, needed??
    # line = re.sub('(;LAYER:)(\d+)(.*)', lambda m: m.group(1)+str(int(m.group(2))-cut_layer)+m.group(3), line)
    print line,
